package google_workspace_admin_reconciler

import (
	"context"
	"fmt"
	helpers "github.com/nais/console/pkg/console"
	"github.com/nais/console/pkg/google_jwt"
	log "github.com/sirupsen/logrus"
	"net/http"
	"time"

	"github.com/nais/console/pkg/auditlogger"
	"github.com/nais/console/pkg/config"
	"github.com/nais/console/pkg/dbmodels"
	"github.com/nais/console/pkg/reconcilers"
	"github.com/nais/console/pkg/reconcilers/registry"
	"golang.org/x/oauth2/jwt"
	admin_directory_v1 "google.golang.org/api/admin/directory/v1"
	"google.golang.org/api/googleapi"
	"google.golang.org/api/option"
	"gorm.io/gorm"
)

type gcpReconciler struct {
	auditLogger auditlogger.AuditLogger
	domain      string
	config      *jwt.Config
	system      dbmodels.System
}

const (
	Name                    = "google:workspace-admin"
	OpCreate                = "google:workspace-admin:create"
	OpAddMember             = "google:workspace-admin:add-member"
	OpAddMembers            = "google:workspace-admin:add-members"
	OpDeleteMember          = "google:workspace-admin:delete-member"
	OpAddToGKESecurityGroup = "google:workspace-admin:add-to-gke-security-group"
)

func init() {
	registry.Register(Name, NewFromConfig)
}

func New(system dbmodels.System, auditLogger auditlogger.AuditLogger, domain string, config *jwt.Config) *gcpReconciler {
	return &gcpReconciler{
		auditLogger: auditLogger,
		domain:      domain,
		config:      config,
		system:      system,
	}
}

func NewFromConfig(db *gorm.DB, cfg *config.Config, system dbmodels.System, auditLogger auditlogger.AuditLogger) (reconcilers.Reconciler, error) {
	if !cfg.Google.Enabled {
		return nil, reconcilers.ErrReconcilerNotEnabled
	}

	config, err := google_jwt.GetConfig(cfg.Google.CredentialsFile, cfg.Google.DelegatedUser)

	if err != nil {
		return nil, fmt.Errorf("get google jwt config: %w", err)
	}

	return New(system, auditLogger, cfg.PartnerDomain, config), nil
}

func (s *gcpReconciler) Reconcile(ctx context.Context, corr dbmodels.Correlation, team dbmodels.Team) error {
	client := s.config.Client(ctx)

	srv, err := admin_directory_v1.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		return fmt.Errorf("retrieve directory client: %s", err)
	}

	grp, err := s.getOrCreateGroup(srv.Groups, corr, team)
	if err != nil {
		return err
	}

	err = s.connectUsers(srv.Members, grp, corr, team)
	if err != nil {
		return fmt.Errorf("%s: add members to group: %s", OpAddMembers, err)
	}

	err = s.addToGKESecurityGroup(srv.Members, grp, corr, team)
	if err != nil {
		return err
	}

	return nil
}

func (s *gcpReconciler) getOrCreateGroup(groupsService *admin_directory_v1.GroupsService, corr dbmodels.Correlation, team dbmodels.Team) (*admin_directory_v1.Group, error) {
	slug := reconcilers.TeamNamePrefix + team.Slug
	email := fmt.Sprintf("%s@%s", slug, s.domain)

	grp, err := groupsService.Get(email).Do()
	if err == nil {
		return grp, nil
	}

	grp = &admin_directory_v1.Group{
		Id:          slug.String(),
		Email:       email,
		Name:        helpers.StringWithFallback(&team.Name, fmt.Sprintf("NAIS team '%s'", team.Slug)),
		Description: helpers.StringWithFallback(team.Purpose, fmt.Sprintf("auto-generated by nais console on %s", time.Now().Format(time.RFC1123Z))),
	}

	grp, err = groupsService.Insert(grp).Do()
	if err != nil {
		return nil, fmt.Errorf("%s: create Google Directory group: %s", OpCreate, err)
	}

	s.auditLogger.Log(OpCreate, corr, s.system, nil, &team, nil, "created Google Directory group '%s'", grp.Email)

	return grp, nil
}

func (s *gcpReconciler) connectUsers(membersService *admin_directory_v1.MembersService, grp *admin_directory_v1.Group, corr dbmodels.Correlation, team dbmodels.Team) error {
	remoteMembers, err := membersService.List(grp.Id).Do()
	if err != nil {
		return fmt.Errorf("%s: list existing members in Google Directory group: %s", OpAddMembers, err)
	}

	localMembers := helpers.DomainUsers(team.Users, s.domain)

	deleteMembers := extraMembers(remoteMembers.Members, localMembers)
	createMembers := missingUsers(remoteMembers.Members, localMembers)
	deleted := 0
	created := 0

	for _, member := range deleteMembers {
		err = membersService.Delete(grp.Id, member.Id).Do()
		if err != nil {
			fmt.Errorf("%s: delete member '%s' from Google Directory group '%s': %s", OpDeleteMember, member.Email, grp.Email, err)
			continue
		}
		deleted++
		// FIXME: connect audit log with database user, if exists
		s.auditLogger.Log(OpDeleteMember, corr, s.system, nil, &team, nil, "deleted member '%s' from Google Directory group '%s'", member.Email, grp.Email)
	}

	for _, user := range createMembers {
		if user.Email == nil {
			continue
		}
		member := &admin_directory_v1.Member{
			Email: *user.Email,
		}
		_, err = membersService.Insert(grp.Id, member).Do()
		if err != nil {
			log.Errorf("%s: add member '%s' to Google Directory group '%s': %s", OpAddMember, member.Email, grp.Email, err)
			continue
		}
		created++
		// FIXME: connect audit log with database user, if exists
		s.auditLogger.Log(OpAddMember, corr, s.system, nil, &team, nil, "added member '%s' to Google Directory group '%s'", member.Email, grp.Email)
	}

	return nil
}

func (s *gcpReconciler) addToGKESecurityGroup(membersService *admin_directory_v1.MembersService, grp *admin_directory_v1.Group, corr dbmodels.Correlation, team dbmodels.Team) error {
	const groupPrefix = "gke-security-groups@"
	groupKey := groupPrefix + s.domain

	member := &admin_directory_v1.Member{
		Email: grp.Email,
	}

	_, err := membersService.Insert(groupKey, member).Do()
	if err != nil {
		googleError, ok := err.(*googleapi.Error)
		if ok && googleError.Code == http.StatusConflict {
			return nil
		}
		return fmt.Errorf("%s: add group '%s' to GKE security group '%s': %s", OpAddToGKESecurityGroup, member.Email, groupKey, err)
	}

	s.auditLogger.Log(OpAddToGKESecurityGroup, corr, s.system, nil, &team, nil, "added group '%s' to GKE security group '%s'", member.Email, groupKey)

	return nil
}

// Given a list of Google group members and a list of users,
// return users not present in members directory.
func missingUsers(members []*admin_directory_v1.Member, users []*dbmodels.User) []*dbmodels.User {
	userMap := make(map[string]*dbmodels.User)
	for _, user := range users {
		if user.Email == nil {
			continue
		}
		userMap[*user.Email] = user
	}
	for _, member := range members {
		delete(userMap, member.Email)
	}
	users = make([]*dbmodels.User, 0, len(userMap))
	for _, user := range userMap {
		users = append(users, user)
	}
	return users
}

// Given a list of Google group members and a list of users,
// return members not present in user list.
func extraMembers(members []*admin_directory_v1.Member, users []*dbmodels.User) []*admin_directory_v1.Member {
	memberMap := make(map[string]*admin_directory_v1.Member)
	for _, member := range members {
		memberMap[member.Email] = member
	}
	for _, user := range users {
		if user.Email == nil {
			continue
		}
		delete(memberMap, *user.Email)
	}
	members = make([]*admin_directory_v1.Member, 0, len(memberMap))
	for _, member := range memberMap {
		members = append(members, member)
	}
	return members
}
