package gcp_team_reconciler

import (
	"context"
	"fmt"
	"time"

	"github.com/nais/console/pkg/dbmodels"
	"github.com/nais/console/pkg/reconcilers"
	"golang.org/x/oauth2/jwt"
	admin_directory_v1 "google.golang.org/api/admin/directory/v1"
	"google.golang.org/api/option"
)

type gcpReconciler struct {
	logs   chan<- *dbmodels.AuditLog
	domain string
	config *jwt.Config
}

func New(logs chan<- *dbmodels.AuditLog, domain string, config *jwt.Config) *gcpReconciler {
	return &gcpReconciler{
		logs:   logs,
		domain: domain,
		config: config,
	}
}

func (s *gcpReconciler) Name() string {
	return "gcp:team"
}

func (s *gcpReconciler) Op(operation string) string {
	return s.Name() + ":" + operation
}

// error -> requeue?
func (s *gcpReconciler) Reconcile(ctx context.Context, in reconcilers.Input) error {
	client := s.config.Client(ctx)

	srv, err := admin_directory_v1.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		return in.AuditLog(nil, false, s.Op("create"), "retrieve directory client: %s", err)
	}

	grp, err := s.getOrCreateGroup(srv, in)
	if err != nil {
		return in.AuditLog(nil, false, s.Op("create"), "ensure group exists: %s", err)
	}

	err = s.connectUsers(srv, grp, in)
	if err != nil {
		return in.AuditLog(nil, false, s.Op("connect-users"), "connect users: %s", err)
	}

	return nil
}

func (s *gcpReconciler) getOrCreateGroup(srv *admin_directory_v1.Service, in reconcilers.Input) (*admin_directory_v1.Group, error) {
	if in.Team == nil || in.Team.Slug == nil {
		return nil, fmt.Errorf("refusing to create team with empty slug")
	}

	const teamPrefix = "nais-team"
	slug := fmt.Sprintf("%s-%s", teamPrefix, *in.Team.Slug)
	email := fmt.Sprintf("%s@%s", slug, s.domain)

	grp, err := srv.Groups.Get(email).Do()
	if err == nil {
		return grp, nil
	}

	grp = &admin_directory_v1.Group{
		Id:          slug,
		Email:       email,
		Name:        stringWithFallback(in.Team.Name, fmt.Sprintf("NAIS team '%s'", *in.Team.Slug)),
		Description: stringWithFallback(in.Team.Purpose, fmt.Sprintf("auto-generated by nais console on %s", time.Now().Format(time.RFC1123Z))),
	}

	grp, err = srv.Groups.Insert(grp).Do()
	if err != nil {
		return nil, fmt.Errorf("create new group: %w", err)
	}

	s.logs <- in.AuditLog(nil, true, s.Op("create"), "successfully created team")

	return grp, nil
}

func (s *gcpReconciler) connectUsers(srv *admin_directory_v1.Service, grp *admin_directory_v1.Group, in reconcilers.Input) error {
	members, err := srv.Members.List(grp.Id).Do()
	if err != nil {
		return fmt.Errorf("list members: %w", err)
	}

	deleteMembers := extraMembers(members.Members, in.Team.Users)
	createUsers := missingUsers(members.Members, in.Team.Users)

	for _, member := range deleteMembers {
		err = srv.Members.Delete(grp.Id, member.Id).Do()
		if err != nil {
			return fmt.Errorf("delete user %s from group %s: %w", member.Email, grp.Email, err)
		}
		s.logs <- in.AuditLog(nil, true, s.Op("delete-member"), "deleted %s from gcp group %s", member.Email, grp.Email)
	}

	for _, user := range createUsers {
		if user.Email == nil {
			continue
		}
		member := &admin_directory_v1.Member{
			Email: *user.Email,
		}
		_, err = srv.Members.Insert(grp.Id, member).Do()
		if err != nil {
			return fmt.Errorf("add user %s to group %s: %w", *user.Email, grp.Email, err)
		}
		s.logs <- in.AuditLog(nil, true, s.Op("add-member"), "added %s to gcp group %s", member.Email, grp.Email)
	}

	return nil
}

// Given a list of Google group members and a list of users,
// return users not present in members directory.
func missingUsers(members []*admin_directory_v1.Member, users []*dbmodels.User) []*dbmodels.User {
	userMap := make(map[string]*dbmodels.User)
	for _, user := range users {
		if user.Email == nil {
			continue
		}
		userMap[*user.Email] = user
	}
	for _, member := range members {
		delete(userMap, member.Email)
	}
	users = make([]*dbmodels.User, 0, len(userMap))
	for _, user := range userMap {
		users = append(users, user)
	}
	return users
}

// Given a list of Google group members and a list of users,
// return members not present in user list.
func extraMembers(members []*admin_directory_v1.Member, users []*dbmodels.User) []*admin_directory_v1.Member {
	memberMap := make(map[string]*admin_directory_v1.Member)
	for _, member := range members {
		memberMap[member.Email] = member
	}
	for _, user := range users {
		if user.Email == nil {
			continue
		}
		delete(memberMap, *user.Email)
	}
	members = make([]*admin_directory_v1.Member, 0, len(memberMap))
	for _, member := range memberMap {
		members = append(members, member)
	}
	return members
}

func stringWithFallback(strp *string, fallback string) string {
	if strp == nil {
		return fallback
	}
	return *strp
}
