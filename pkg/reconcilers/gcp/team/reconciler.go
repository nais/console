package gcp_team_reconciler

import (
	"context"
	"fmt"
	"time"

	"github.com/nais/console/pkg/dbmodels"
	"github.com/nais/console/pkg/reconcilers"
	"golang.org/x/oauth2/jwt"
	admin_directory_v1 "google.golang.org/api/admin/directory/v1"
	"google.golang.org/api/option"
)

type gcpReconciler struct {
	logs   chan<- *dbmodels.AuditLog
	domain string
	config *jwt.Config
}

func New(logs chan<- *dbmodels.AuditLog, domain string, config *jwt.Config) *gcpReconciler {
	return &gcpReconciler{
		logs:   logs,
		domain: domain,
		config: config,
	}
}

func (s *gcpReconciler) Name() string {
	return "gcp:team"
}

func (s *gcpReconciler) Op(operation string) string {
	return s.Name() + ":" + operation
}

// error -> requeue?
func (s *gcpReconciler) Reconcile(ctx context.Context, in reconcilers.Input) error {
	client := s.config.Client(ctx)

	srv, err := admin_directory_v1.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		return in.AuditLog(nil, false, s.Op("create"), "retrieve directory client: %s", err)
	}

	_, err = s.getOrCreateGroup(srv, in)
	if err != nil {
		return in.AuditLog(nil, false, s.Op("create"), "ensure group exists: %s", err)
	}

	return nil
}

func (s *gcpReconciler) getOrCreateGroup(srv *admin_directory_v1.Service, in reconcilers.Input) (*admin_directory_v1.Group, error) {
	if in.Team == nil || in.Team.Slug == nil {
		return nil, fmt.Errorf("refusing to create team with empty slug")
	}

	const teamPrefix = "nais-team"
	slug := fmt.Sprintf("%s-%s", teamPrefix, *in.Team.Slug)
	email := fmt.Sprintf("%s@%s", slug, s.domain)

	grp, err := srv.Groups.Get(email).Do()
	if err == nil {
		return grp, nil
	}

	grp = &admin_directory_v1.Group{
		Id:          slug,
		Email:       email,
		Name:        stringWithFallback(in.Team.Name, fmt.Sprintf("NAIS team '%s'", *in.Team.Slug)),
		Description: stringWithFallback(in.Team.Purpose, fmt.Sprintf("auto-generated by nais console on %s", time.Now().Format(time.RFC1123Z))),
	}

	grp, err = srv.Groups.Insert(grp).Do()
	if err != nil {
		return nil, fmt.Errorf("create new group: %w", err)
	}

	s.logs <- in.AuditLog(nil, true, s.Op("create"), "successfully created team")

	return grp, nil
}

func stringWithFallback(strp *string, fallback string) string {
	if strp == nil {
		return fallback
	}
	return *strp
}
