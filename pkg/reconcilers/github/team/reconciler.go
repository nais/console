package github_team_reconciler

import (
	"context"
	"errors"
	"fmt"
	helpers "github.com/nais/console/pkg/console"
	log "github.com/sirupsen/logrus"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/bradleyfalzon/ghinstallation/v2"
	"github.com/google/go-github/v43/github"
	"github.com/nais/console/pkg/auditlogger"
	"github.com/nais/console/pkg/config"
	"github.com/nais/console/pkg/dbmodels"
	"github.com/nais/console/pkg/reconcilers"
	"github.com/nais/console/pkg/reconcilers/registry"
	"github.com/shurcooL/githubv4"
	"gorm.io/gorm"
)

const (
	Name           = "github:team"
	OpCreate       = "github:team:create"
	OpAddMembers   = "github:team:add-members"
	OpAddMember    = "github:team:add-member"
	OpDeleteMember = "github:team:delete-member"
	OpMapSSOUser   = "github:team:map-sso-user"
)

var errGitHubUserNotFound = errors.New("GitHub user does not exist")

func init() {
	registry.Register(Name, NewFromConfig)
}

func New(db *gorm.DB, system dbmodels.System, auditLogger auditlogger.AuditLogger, org, domain string, teamsService TeamsService, graphClient GraphClient) *gitHubReconciler {
	return &gitHubReconciler{
		db:           db,
		system:       system,
		auditLogger:  auditLogger,
		org:          org,
		domain:       domain,
		teamsService: teamsService,
		graphClient:  graphClient,
	}
}

func NewFromConfig(db *gorm.DB, cfg *config.Config, system dbmodels.System, auditLogger auditlogger.AuditLogger) (reconcilers.Reconciler, error) {
	if !cfg.GitHub.Enabled {
		return nil, reconcilers.ErrReconcilerNotEnabled
	}

	transport, err := ghinstallation.NewKeyFromFile(
		http.DefaultTransport,
		cfg.GitHub.AppID,
		cfg.GitHub.AppInstallationID,
		cfg.GitHub.PrivateKeyPath,
	)
	if err != nil {
		return nil, err
	}

	// Note that both HTTP clients and transports are safe for concurrent use according to the docs,
	// so we can safely reuse them across objects and concurrent synchronizations.
	httpClient := &http.Client{
		Transport: transport,
	}
	restClient := github.NewClient(httpClient)
	graphClient := githubv4.NewClient(httpClient)

	return New(db, system, auditLogger, cfg.GitHub.Organization, cfg.PartnerDomain, restClient.Teams, graphClient), nil
}

func (s *gitHubReconciler) Reconcile(ctx context.Context, input reconcilers.Input) error {
	githubTeam, err := s.getOrCreateTeam(ctx, input.Corr, input.Team)
	if err != nil {
		return err
	}

	return s.connectUsers(ctx, githubTeam, input.Corr, input.Team)
}

func (s *gitHubReconciler) getOrCreateTeam(ctx context.Context, corr dbmodels.Correlation, team dbmodels.Team) (*github.Team, error) {
	existingTeam, resp, err := s.teamsService.GetTeamBySlug(ctx, s.org, string(team.Slug))
	if resp == nil && err != nil {
		return nil, err
	}

	switch resp.StatusCode {
	case http.StatusOK:
		return existingTeam, nil
	case http.StatusNotFound:
		break
	default:
		body, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("server raised error: %s: %s", resp.Status, string(body))
	}

	description := helpers.StringWithFallback(
		team.Purpose,
		fmt.Sprintf("Team '%v', auto-generated by nais console on %s", team.Name, time.Now().Format(time.RFC1123Z)),
	)
	newTeam := github.NewTeam{
		Name:        string(team.Slug),
		Description: &description,
	}
	githubTeam, resp, err := s.teamsService.CreateTeam(ctx, s.org, newTeam)
	err = httpError(http.StatusCreated, *resp, err)
	if err != nil {
		return nil, fmt.Errorf("%s: create GitHub team '%s': %s", OpCreate, newTeam, err)
	}

	s.auditLogger.Logf(OpCreate, corr, s.system, nil, &team, nil, "created GitHub team '%s'", newTeam)

	return githubTeam, nil
}

func (s *gitHubReconciler) connectUsers(ctx context.Context, githubTeam *github.Team, corr dbmodels.Correlation, team dbmodels.Team) error {
	membersAccordingToGitHub, err := s.getTeamMembers(ctx, *githubTeam.Slug)
	if err != nil {
		return fmt.Errorf("%s: list existing members in GitHub team '%s': %w", OpAddMembers, *githubTeam.Slug, err)
	}

	membersAccordingToConsole := helpers.DomainUsers(team.Users, s.domain)
	consoleUserWithGitHubUser, err := s.mapSSOUsers(ctx, membersAccordingToConsole)
	if err != nil {
		return err
	}

	var targetUser *dbmodels.User
	membersToRemove := remoteOnlyMembers(membersAccordingToGitHub, consoleUserWithGitHubUser)
	for _, gitHubUser := range membersToRemove {
		username := gitHubUser.GetLogin()
		resp, err := s.teamsService.RemoveTeamMembershipBySlug(ctx, s.org, *githubTeam.Slug, username)
		err = httpError(http.StatusNoContent, *resp, err)
		if err != nil {
			log.Warnf("%s: unable to remove member '%s' from GitHub team '%s': %s", OpDeleteMember, username, *githubTeam.Slug, err)
			continue
		}

		targetUser = nil
		email, err := s.getEmailFromGitHubUsername(ctx, username)
		if err != nil {
			log.Warnf("%s: unable to get email from GitHub username '%s' for audit log purposes: %s", OpDeleteMember, username, err)
		}

		if email != nil {
			targetUser = dbmodels.GetUserByEmail(s.db, *email)
		}

		s.auditLogger.Logf(OpDeleteMember, corr, s.system, nil, &team, targetUser, "deleted member '%s' from GitHub team '%s'", username, *githubTeam.Slug)
	}

	membersToAdd := localOnlyMembers(consoleUserWithGitHubUser, membersAccordingToGitHub)
	for username, consoleUser := range membersToAdd {
		_, resp, err := s.teamsService.AddTeamMembershipBySlug(ctx, s.org, *githubTeam.Slug, username, &github.TeamAddTeamMembershipOptions{})
		err = httpError(http.StatusOK, *resp, err)
		if err != nil {
			log.Warnf("%s: unable to add member '%s' to GitHub team '%s': %s", OpAddMember, username, *githubTeam.Slug, err)
			continue
		}

		s.auditLogger.Logf(OpAddMember, corr, s.system, nil, &team, consoleUser, "added member '%s' to GitHub team '%s'", username, *githubTeam.Slug)
	}

	return nil
}

// getTeamMembers Get all team members in a GitHub team using a paginated query
func (s *gitHubReconciler) getTeamMembers(ctx context.Context, slug string) ([]*github.User, error) {
	const maxPerPage = 100
	opt := &github.TeamListTeamMembersOptions{
		ListOptions: github.ListOptions{
			PerPage: maxPerPage,
		},
	}

	allMembers := make([]*github.User, 0)
	for {
		members, resp, err := s.teamsService.ListTeamMembersBySlug(ctx, s.org, slug, opt)
		err = httpError(http.StatusOK, *resp, err)
		if err != nil {
			return nil, err
		}
		allMembers = append(allMembers, members...)
		if resp.NextPage == 0 {
			break
		}
		opt.Page = resp.NextPage
	}

	return allMembers, nil
}

// localOnlyMembers Given a mapping of GitHub usernames to Console users, and a list of GitHub team members according to
// GitHub, return members only present in the mapping.
func localOnlyMembers(consoleUsers map[string]*dbmodels.User, membersAccordingToGitHub []*github.User) map[string]*dbmodels.User {
	gitHubUsernameMap := make(map[string]*github.User, 0)
	for _, gitHubUser := range membersAccordingToGitHub {
		gitHubUsernameMap[gitHubUser.GetLogin()] = gitHubUser
	}

	localOnly := make(map[string]*dbmodels.User, 0)
	for gitHubUsername, consoleUser := range consoleUsers {
		if _, exists := gitHubUsernameMap[gitHubUsername]; !exists {
			localOnly[gitHubUsername] = consoleUser
		}
	}
	return localOnly
}

// remoteOnlyMembers Given a list of GitHub team members and a mapping of known GitHub usernames to Console users,
// return members not present in the mapping.
func remoteOnlyMembers(membersAccordingToGitHub []*github.User, consoleUsers map[string]*dbmodels.User) []*github.User {
	unknownMembers := make([]*github.User, 0)
	for _, member := range membersAccordingToGitHub {
		if _, exists := consoleUsers[member.GetLogin()]; !exists {
			unknownMembers = append(unknownMembers, member)
		}
	}
	return unknownMembers
}

// mapSSOUsers Return a mapping of GitHub usernames to Console user objects. Console users with no matching GitHub user
// will be ignored.
func (s *gitHubReconciler) mapSSOUsers(ctx context.Context, users []*dbmodels.User) (map[string]*dbmodels.User, error) {
	userMap := make(map[string]*dbmodels.User)
	for _, user := range users {
		githubUsername, err := s.getGitHubUsernameFromEmail(ctx, user.Email)
		if err == errGitHubUserNotFound {
			log.Warnf("%s: no GitHub user for email: '%s'", OpMapSSOUser, user.Email)
			continue
		}
		if err != nil {
			return nil, err
		}
		userMap[*githubUsername] = user
	}

	return userMap, nil
}

// getGitHubUsernameFromEmail Look up a GitHub username from an SSO e-mail address connected to that user account.
func (s *gitHubReconciler) getGitHubUsernameFromEmail(ctx context.Context, email string) (*string, error) {
	var query LookupGitHubSamlUserByEmail

	variables := map[string]interface{}{
		"org":      githubv4.String(s.org),
		"username": githubv4.String(email),
	}

	err := s.graphClient.Query(ctx, &query, variables)
	if err != nil {
		return nil, err
	}

	nodes := query.Organization.SamlIdentityProvider.ExternalIdentities.Nodes
	if len(nodes) == 0 {
		return nil, errGitHubUserNotFound
	}

	username := string(nodes[0].User.Login)
	return &username, nil
}

// getEmailFromGitHubUsername Look up a GitHub username from an SSO e-mail address connected to that user account.
func (s *gitHubReconciler) getEmailFromGitHubUsername(ctx context.Context, username string) (*string, error) {
	var query LookupGitHubSamlUserByGitHubUsername

	variables := map[string]interface{}{
		"org":   githubv4.String(s.org),
		"login": githubv4.String(username),
	}

	err := s.graphClient.Query(ctx, &query, variables)
	if err != nil {
		return nil, err
	}

	nodes := query.Organization.SamlIdentityProvider.ExternalIdentities.Nodes
	if len(nodes) == 0 {
		return nil, errGitHubUserNotFound
	}

	email := strings.ToLower(string(nodes[0].SamlIdentity.Username))
	return &email, nil
}

func httpError(expected int, resp github.Response, err error) error {
	if err != nil {
		return err
	}
	if resp.StatusCode != expected {
		if resp.Body == nil {
			return errors.New("unknown error")
		}
		body, _ := ioutil.ReadAll(resp.Body)
		return fmt.Errorf("server raised error: %s: %s", resp.Status, string(body))
	}
	return nil
}
